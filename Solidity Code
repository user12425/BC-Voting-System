// SPDX-License-Identifier: MIT pragma solidity >= 0.7.0 <0.9.0;

contract Ballot {
// VARIABLES
struct Vote {
address voterAddress;
uint8 choice; // Use uint8 for representing choices (0 for Chinese, 1 for Italian, 2 for Spanish)
}

struct Voter {
string voterName; bool voted;
}

uint[] private choiceCounts; // Array to store the counts for each choice
uint public totalVoter = 0; uint public totalVote = 0;

address public ballotOfficialAddress; string public ballotOfficialName; string public proposal;
string[] public choices; // Array to store the choices

mapping(address => Voter) public voterRegister; mapping(uint => Vote) private votes;

enum State { Created, Voting, Ended } State public state;

// MODIFIERS
modifier condition(bool _condition) { require(_condition, "Condition not met");


_;
}

modifier onlyOfficial() {
require(msg.sender == ballotOfficialAddress, "Not authorized");
_;
}

modifier inState(State _state) {
require(state == _state, "Invalid state");
_;
}

// FUNCTION
constructor(
string memory _ballotOfficialName, string memory _proposal,
string[] memory _choices
) {
require(_choices.length == 3, "Must provide exactly three
choices");
ballotOfficialAddress = msg.sender; ballotOfficialName = _ballotOfficialName; proposal = _proposal;
state = State.Created;
choiceCounts = new uint[](3); // Initialize the array with three elements
choices = _choices;
}

function addVoter(
address _voterAddress, string memory _voterName
) public
inState(State.Created) onlyOfficial
{
Voter memory v; v.voterName = _voterName; v.voted = false;
 
voterRegister[_voterAddress] = v; totalVoter++;
}

function startVote() public inState(State.Created) onlyOfficial
{
state = State.Voting;
}

function doVote(uint8 _choice) public inState(State.Voting) returns (bool voted)
{
require(_choice < 3, "Invalid choice"); // Ensure the choice is
within the valid range

bool isFound = false; if(bytes(voterRegister[msg.sender].voterName).length != 0
&& !voterRegister[msg.sender].voted)
{
voterRegister[msg.sender].voted = true; Vote memory v;
v.voterAddress = msg.sender; v.choice = _choice; choiceCounts[_choice]++; votes[totalVote] = v; totalVote++;
isFound = true;
}
return isFound;
}

function endVote() public
inState(State.Voting) onlyOfficial
 
{
state = State.Ended;
// You can now access the counts for each choice using choiceCounts[0], choiceCounts[1], choiceCounts[2]
}

function getChoiceDescription(uint8 _choice) public view returns (string memory) {
require(_choice < 3, "Invalid choice"); return choices[_choice];
}

function getVoteCounts() public view returns (uint, uint, uint) { require(state == State.Ended, "Voting has not ended yet");
return (choiceCounts[0], choiceCounts[1], choiceCounts[2]);
}
}
